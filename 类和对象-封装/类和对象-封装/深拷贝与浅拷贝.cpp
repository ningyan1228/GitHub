#include <iostream>
using namespace std;
#include<string>


/* ----------------------------------------
深浅拷贝是面试经典问题，也是常见的一个坑

浅拷贝：简单的赋值拷贝操作(编译器提供的默认拷贝

深拷贝：在堆区重新申请空间，进行拷贝操作

用钥匙和文件柜的比喻秒懂：

浅拷贝：配钥匙

你（对象A）有个文件柜（堆内存），
我（对象B）直接复制你的钥匙
结果：我俩用同一把钥匙开同一个柜子
→ 若我删了文件，你的文件也没了（双重释放崩溃）
深拷贝：复印文件+新柜子

我（对象B）把你柜子里的文件全部复印一份，存进我的新柜子
结果：两套独立文件柜 → 互不影响
黄金法则：当类中有指针指向堆内存时，
必须手动实现深拷贝（重写拷贝构造函数和赋值运算符）
-------------------------------------------
*/
class Basa 
{

public:
    //行为
    Basa() {
        b_height = new int(0);
        cout << "Basa的默认构造函数调用" << endl;
    }
    Basa(int id,int height) {
        cout << "Basa的有参构造函数调用" << endl;
        b_id = id;
        b_height =new int(height);
        //指针b_height 去接收堆区数据
        //在堆区开辟内存
        
    }
    //深拷贝 自己写一个拷贝构造函数
    Basa(const Basa& p) {
        //&符号表示引用（reference）
        /*
        p 是原对象的"外号"
        p 不是原对象的副本，而是原对象的别名（外号）
        操作 p 就像直接操作原对象，但不会产生新对象

        相当于直接给梅西起个外号 "p"
        → 操作 "p" 就是直接操作梅西本人，
        但承诺不修改他（const）
        */
        cout << "Basa的拷贝构造函数调用" << endl;
        b_id = p.b_id;
        //b_height = p.b_height;
        //编译器默认提供的拷贝函数 有问题 会拷贝一样的地址
        //深拷贝操作
        b_height = new int(*p.b_height);
        //*解引用 解出来180的内容
        /*
        含义：解引用（Dereference）
        作用：取出指针指向的堆内存中的实际值
        类比：
        p.b_height 是柜子的钥匙（指针）
        *p.b_height 是用钥匙打开柜子，取出里面的文件（值）
        为什么需要 *：
        深拷贝需要复制值，而不是复制钥匙（指针地址）

        
        */
    }
    /*
    （堆区数据）内容180完全一样，地址不同：
    新文件存放在另一个地址空间（不同的堆内存地址）
    各自管理自己的内存，析构时互不干扰
    ------------------------------------------------------
    *p.b_height:
    p 是被拷贝的对象（比如梅西）
    p.b_height 是原对象的指针
    （指向存储身高的堆内存地址，比如 0x1234）
    * 解引用：*p.b_height 
    表示取出这个地址里存储的实际值（比如 180）
    new int(...)
    在堆区新申请一块内存（比如新地址 0x5678）
    把刚才取出的值（180）存入新内存
    b_height = ...
    让当前对象（比如亚马尔）的 b_height 指针指向这块新内存

    析构时各自释放自己的内存 → 安全无崩溃
总结：这行代码是深拷贝的灵魂，让每个对象拥有独立的内存空间，
彻底解决浅拷贝的共享灾难！
    */

    ~Basa() {  //析构代码，将堆区开辟的数据做释放
        if (b_height != NULL) {//占着内存呢 就说明要去释放他。
            delete b_height; //释放内存
            b_height = NULL;
        }

        cout << "Basa的析构函数调用" << endl;
    }

    //Basa(const Basa &other) {
    //cout << "Basa的拷贝构造函数调用" << endl;
    //b_id = other.b_id;
    //// 重新分配堆内存，避免多个对象共享同一块内存
    //b_height = new int(*(other.b_height));
//}

public:
    //成员 属性 
    int b_id = 10;
    int * b_height;
};


//测试案例
void test_1()
{
    Basa messi(10,180);
    cout << "messi的球员号码是： " << messi.b_id 
         <<"身高为： " << *messi.b_height << endl;
    Basa 亚马尔(messi);  //编译器提供了浅拷贝
    // 默认的浅拷贝导致指针 b_height 指向同一块内存
    cout << "亚马尔的球衣号码是： " << 亚马尔.b_id 
         <<"身高为： " <<*亚马尔.b_height<<endl;
    //*解引用 加上就输出值 不加就是输出地址
   
}
/*
在 Basa 类中 没有提供拷贝构造函数，因此 Basa 亚马尔(messi); 
使用 编译器提供的默认拷贝构造函数，
它只是 简单地复制对象的所有成员变量（包括指针地址）。
这意味着：
messi.b_height 和 亚马尔.b_height 指向同一块堆内存。
messi.b_height ---> [180]  (在堆区)
亚马尔.b_height ---> [180]  (同样指向 messi 的内存)

析构函数导致 "二次释放"，
test_1() 结束时，messi 和 亚马尔 都会调用 析构函数：

~Basa() {
    if (b_height != NULL) {
        delete b_height;  // 释放内存
        b_height = NULL;
    }
}

析构时，亚马尔 先 delete 这个内存（栈先进后出，亚马尔后进先出）
析构顺序：后创建的先释放
后进的人先出去（析构顺序是逆序的）
→ （亚马尔）先出门，用钥匙锁门（delete 堆内存）
→ 锁完门后钥匙作废（内存被释放）
然后（messi）出门，试图用同一把钥匙锁已经锁过的门
→ 钥匙失效（内存已被释放） → 程序崩溃！
接着 messi 析构时再次 delete 同一块内存 → 程序崩溃
浅拷贝导致堆区内存重复释放，
解决办法->深拷贝 我自己写一个拷贝函数，堆区存放的内容一样，地址不一样
*/


int main12() {

    test_1();

    system("pause");
    return 0;
}