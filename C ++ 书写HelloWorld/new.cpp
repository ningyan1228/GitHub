#include <iostream>
using namespace std;
#include<string>

// new的基本语法
int * func()  //函数声明：返回int指针
{
	//在堆区创建 整型数据
	//new 返回的是 该指针类型的指针
	int* p = new int(10);//创建一个变量，这个变量是10
	// 在堆区分配内存，存入 10
	//new int(10) :在堆区动态分配一个int类型内存，
	// 初始化为10，返回该内存地址
	// int *p ：创建指针变量p，存储堆区内存地址
	return p;  //返回指针
	//将堆区地址返回给调用者（test01函数）
	/*
	堆区分配：
		地址0x1000 → 存储值10
		p → 0x1000  p指向这个地址

	*/
}

void test01()
{
	int* p = func();
	//接收func返回的堆地址
	//p 指向堆区的0x1000地址（值为10）
	cout << *p << endl; //解引用有效指针 → 输出10
	//堆区的数据，由程序员开辟管理，程序员管理释放
	//如果想要释放堆区的数据，利用关键字 ：delete
	delete p;  //释放堆内存，但p仍存储0x1000（变成野指针）
	cout << *p << endl;  //内存已经被释放，再次访问就是非法操作 会报错
	//  危险操作！访问已释放内存 解引用野指针 → 未定义行为（可能输出垃圾值、崩溃等）
	/*
	执行delete后：
		地址0x1000 被系统回收（可能被其他程序使用）
		p → 0x1000（野指针）

*/

}
/*
main()
└─ test01()
   ├─ 调用 func()
   │   ├─ 堆分配内存 → 地址0x1000，值10
   │   └─ 返回0x1000
   ├─ 输出 *0x1000 → 10
   ├─ 释放0x1000内存
   └─ 错误访问 *0x1000 → 未定义行为
   通过这个示例，可以深刻理解动态内存管理的重要性。
   务必遵循谁申请谁释放的原则，
   并在释放后及时置空指针！
*/



//在堆区利用new开辟数组
void test02()
{
	int * arr = new int[10];  //10代表数组有10个元素
	//数组的名称就是首地址
	for (int i = 0;i < 10;i++)  //操作数组
	{
		arr[i] = i + 100;  //给10个元素赋值100~109
	}

	for (int i = 0;i < 10;i++)
	{
		cout << arr[i] << endl;
	}

	//释放堆区数组,要加[]
	delete[] arr;

}

int main167()
{

	//test01();  //调用测试函数
	test02();
	
	system("pause");  // 暂停控制台（Windows特有）
	return 0;
}